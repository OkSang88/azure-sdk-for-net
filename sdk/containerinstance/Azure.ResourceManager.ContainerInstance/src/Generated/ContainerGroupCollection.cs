// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager;
using Azure.ResourceManager.ContainerInstance.Models;
using Azure.ResourceManager.Core;
using Azure.ResourceManager.Resources;

namespace Azure.ResourceManager.ContainerInstance
{
    /// <summary> A class representing collection of ContainerGroup and their operations over its parent. </summary>
    public partial class ContainerGroupCollection : ArmCollection, IEnumerable<ContainerGroup>, IAsyncEnumerable<ContainerGroup>
    {
        private readonly ClientDiagnostics _clientDiagnostics;
        private readonly ContainerGroupsRestOperations _containerGroupsRestClient;

        /// <summary> Initializes a new instance of the <see cref="ContainerGroupCollection"/> class for mocking. </summary>
        protected ContainerGroupCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="ContainerGroupCollection"/> class. </summary>
        /// <param name="parent"> The resource representing the parent resource. </param>
        internal ContainerGroupCollection(ArmResource parent) : base(parent)
        {
            _clientDiagnostics = new ClientDiagnostics(ClientOptions);
            _containerGroupsRestClient = new ContainerGroupsRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceGroup.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceGroup.ResourceType), nameof(id));
        }

        // Collection level operations.

        /// <summary> Create or update container groups with specified configurations. </summary>
        /// <param name="containerGroupName"> The name of the container group. </param>
        /// <param name="containerGroup"> The properties of the container group to be created or updated. </param>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerGroupName"/> or <paramref name="containerGroup"/> is null. </exception>
        public virtual ContainerGroupCreateOrUpdateOperation CreateOrUpdate(bool waitForCompletion, string containerGroupName, ContainerGroupData containerGroup, CancellationToken cancellationToken = default)
        {
            if (containerGroupName == null)
            {
                throw new ArgumentNullException(nameof(containerGroupName));
            }
            if (containerGroup == null)
            {
                throw new ArgumentNullException(nameof(containerGroup));
            }

            using var scope = _clientDiagnostics.CreateScope("ContainerGroupCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _containerGroupsRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, containerGroupName, containerGroup, cancellationToken);
                var operation = new ContainerGroupCreateOrUpdateOperation(Parent, _clientDiagnostics, Pipeline, _containerGroupsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, containerGroupName, containerGroup).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create or update container groups with specified configurations. </summary>
        /// <param name="containerGroupName"> The name of the container group. </param>
        /// <param name="containerGroup"> The properties of the container group to be created or updated. </param>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerGroupName"/> or <paramref name="containerGroup"/> is null. </exception>
        public async virtual Task<ContainerGroupCreateOrUpdateOperation> CreateOrUpdateAsync(bool waitForCompletion, string containerGroupName, ContainerGroupData containerGroup, CancellationToken cancellationToken = default)
        {
            if (containerGroupName == null)
            {
                throw new ArgumentNullException(nameof(containerGroupName));
            }
            if (containerGroup == null)
            {
                throw new ArgumentNullException(nameof(containerGroup));
            }

            using var scope = _clientDiagnostics.CreateScope("ContainerGroupCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _containerGroupsRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, containerGroupName, containerGroup, cancellationToken).ConfigureAwait(false);
                var operation = new ContainerGroupCreateOrUpdateOperation(Parent, _clientDiagnostics, Pipeline, _containerGroupsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, containerGroupName, containerGroup).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the properties of the specified container group in the specified subscription and resource group. The operation returns the properties of each container group including containers, image registry credentials, restart policy, IP address type, OS type, state, and volumes. </summary>
        /// <param name="containerGroupName"> The name of the container group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerGroupName"/> is null. </exception>
        public virtual Response<ContainerGroup> Get(string containerGroupName, CancellationToken cancellationToken = default)
        {
            if (containerGroupName == null)
            {
                throw new ArgumentNullException(nameof(containerGroupName));
            }

            using var scope = _clientDiagnostics.CreateScope("ContainerGroupCollection.Get");
            scope.Start();
            try
            {
                var response = _containerGroupsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, containerGroupName, cancellationToken);
                if (response.Value == null)
                    throw _clientDiagnostics.CreateRequestFailedException(response.GetRawResponse());
                return Response.FromValue(new ContainerGroup(Parent, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the properties of the specified container group in the specified subscription and resource group. The operation returns the properties of each container group including containers, image registry credentials, restart policy, IP address type, OS type, state, and volumes. </summary>
        /// <param name="containerGroupName"> The name of the container group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerGroupName"/> is null. </exception>
        public async virtual Task<Response<ContainerGroup>> GetAsync(string containerGroupName, CancellationToken cancellationToken = default)
        {
            if (containerGroupName == null)
            {
                throw new ArgumentNullException(nameof(containerGroupName));
            }

            using var scope = _clientDiagnostics.CreateScope("ContainerGroupCollection.Get");
            scope.Start();
            try
            {
                var response = await _containerGroupsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, containerGroupName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(response.GetRawResponse()).ConfigureAwait(false);
                return Response.FromValue(new ContainerGroup(Parent, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Tries to get details for this resource from the service. </summary>
        /// <param name="containerGroupName"> The name of the container group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerGroupName"/> is null. </exception>
        public virtual Response<ContainerGroup> GetIfExists(string containerGroupName, CancellationToken cancellationToken = default)
        {
            if (containerGroupName == null)
            {
                throw new ArgumentNullException(nameof(containerGroupName));
            }

            using var scope = _clientDiagnostics.CreateScope("ContainerGroupCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _containerGroupsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, containerGroupName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return Response.FromValue<ContainerGroup>(null, response.GetRawResponse());
                return Response.FromValue(new ContainerGroup(this, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Tries to get details for this resource from the service. </summary>
        /// <param name="containerGroupName"> The name of the container group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerGroupName"/> is null. </exception>
        public async virtual Task<Response<ContainerGroup>> GetIfExistsAsync(string containerGroupName, CancellationToken cancellationToken = default)
        {
            if (containerGroupName == null)
            {
                throw new ArgumentNullException(nameof(containerGroupName));
            }

            using var scope = _clientDiagnostics.CreateScope("ContainerGroupCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _containerGroupsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, containerGroupName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return Response.FromValue<ContainerGroup>(null, response.GetRawResponse());
                return Response.FromValue(new ContainerGroup(this, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Tries to get details for this resource from the service. </summary>
        /// <param name="containerGroupName"> The name of the container group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerGroupName"/> is null. </exception>
        public virtual Response<bool> Exists(string containerGroupName, CancellationToken cancellationToken = default)
        {
            if (containerGroupName == null)
            {
                throw new ArgumentNullException(nameof(containerGroupName));
            }

            using var scope = _clientDiagnostics.CreateScope("ContainerGroupCollection.Exists");
            scope.Start();
            try
            {
                var response = GetIfExists(containerGroupName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Tries to get details for this resource from the service. </summary>
        /// <param name="containerGroupName"> The name of the container group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="containerGroupName"/> is null. </exception>
        public async virtual Task<Response<bool>> ExistsAsync(string containerGroupName, CancellationToken cancellationToken = default)
        {
            if (containerGroupName == null)
            {
                throw new ArgumentNullException(nameof(containerGroupName));
            }

            using var scope = _clientDiagnostics.CreateScope("ContainerGroupCollection.Exists");
            scope.Start();
            try
            {
                var response = await GetIfExistsAsync(containerGroupName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a list of container groups in a specified subscription and resource group. This operation returns properties of each container group including containers, image registry credentials, restart policy, IP address type, OS type, state, and volumes. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="ContainerGroup" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<ContainerGroup> GetAll(CancellationToken cancellationToken = default)
        {
            Page<ContainerGroup> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("ContainerGroupCollection.GetAll");
                scope.Start();
                try
                {
                    var response = _containerGroupsRestClient.ListByResourceGroup(Id.SubscriptionId, Id.ResourceGroupName, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ContainerGroup(Parent, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<ContainerGroup> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("ContainerGroupCollection.GetAll");
                scope.Start();
                try
                {
                    var response = _containerGroupsRestClient.ListByResourceGroupNextPage(nextLink, Id.SubscriptionId, Id.ResourceGroupName, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ContainerGroup(Parent, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get a list of container groups in a specified subscription and resource group. This operation returns properties of each container group including containers, image registry credentials, restart policy, IP address type, OS type, state, and volumes. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="ContainerGroup" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<ContainerGroup> GetAllAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<ContainerGroup>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("ContainerGroupCollection.GetAll");
                scope.Start();
                try
                {
                    var response = await _containerGroupsRestClient.ListByResourceGroupAsync(Id.SubscriptionId, Id.ResourceGroupName, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ContainerGroup(Parent, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<ContainerGroup>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("ContainerGroupCollection.GetAll");
                scope.Start();
                try
                {
                    var response = await _containerGroupsRestClient.ListByResourceGroupNextPageAsync(nextLink, Id.SubscriptionId, Id.ResourceGroupName, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ContainerGroup(Parent, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Filters the list of <see cref="ContainerGroup" /> for this resource group represented as generic resources. </summary>
        /// <param name="nameFilter"> The filter used in this operation. </param>
        /// <param name="expand"> Comma-separated list of additional properties to be included in the response. Valid values include `createdTime`, `changedTime` and `provisioningState`. </param>
        /// <param name="top"> The number of results to return. </param>
        /// <param name="cancellationToken"> A token to allow the caller to cancel the call to the service. The default value is <see cref="CancellationToken.None" />. </param>
        /// <returns> A collection of resource that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<GenericResource> GetAllAsGenericResources(string nameFilter, string expand = null, int? top = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ContainerGroupCollection.GetAllAsGenericResources");
            scope.Start();
            try
            {
                var filters = new ResourceFilterCollection(ContainerGroup.ResourceType);
                filters.SubstringFilter = nameFilter;
                return ResourceListOperations.GetAtContext(Parent as ResourceGroup, filters, expand, top, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Filters the list of <see cref="ContainerGroup" /> for this resource group represented as generic resources. </summary>
        /// <param name="nameFilter"> The filter used in this operation. </param>
        /// <param name="expand"> Comma-separated list of additional properties to be included in the response. Valid values include `createdTime`, `changedTime` and `provisioningState`. </param>
        /// <param name="top"> The number of results to return. </param>
        /// <param name="cancellationToken"> A token to allow the caller to cancel the call to the service. The default value is <see cref="CancellationToken.None" />. </param>
        /// <returns> An async collection of resource that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<GenericResource> GetAllAsGenericResourcesAsync(string nameFilter, string expand = null, int? top = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ContainerGroupCollection.GetAllAsGenericResources");
            scope.Start();
            try
            {
                var filters = new ResourceFilterCollection(ContainerGroup.ResourceType);
                filters.SubstringFilter = nameFilter;
                return ResourceListOperations.GetAtContextAsync(Parent as ResourceGroup, filters, expand, top, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<ContainerGroup> IEnumerable<ContainerGroup>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<ContainerGroup> IAsyncEnumerable<ContainerGroup>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }

        // Builders.
        // public ArmBuilder<Azure.Core.ResourceIdentifier, ContainerGroup, ContainerGroupData> Construct() { }
    }
}
