// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager;
using Azure.ResourceManager.Core;
using Azure.ResourceManager.StorSimple8000Series.Models;

namespace Azure.ResourceManager.StorSimple8000Series
{
    /// <summary> A Class representing a Device along with the instance operations that can be performed on it. </summary>
    public partial class Device : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="Device"/> instance. </summary>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string managerName, string deviceName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}";
            return new ResourceIdentifier(resourceId);
        }
        private readonly ClientDiagnostics _clientDiagnostics;
        private readonly DevicesRestOperations _devicesRestClient;
        private readonly ManagersRestOperations _managersRestClient;
        private readonly AlertsRestOperations _alertsRestClient;
        private readonly BackupsRestOperations _backupsRestClient;
        private readonly HardwareComponentGroupsRestOperations _hardwareComponentGroupsRestClient;
        private readonly VolumesRestOperations _volumesRestClient;
        private readonly DeviceData _data;

        /// <summary> Initializes a new instance of the <see cref="Device"/> class for mocking. </summary>
        protected Device()
        {
        }

        /// <summary> Initializes a new instance of the <see cref = "Device"/> class. </summary>
        /// <param name="options"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal Device(ArmResource options, DeviceData data) : base(options, data.Id)
        {
            HasData = true;
            _data = data;
            _clientDiagnostics = new ClientDiagnostics(ClientOptions);
            ClientOptions.TryGetApiVersion(ResourceType, out string apiVersion);
            _devicesRestClient = new DevicesRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _managersRestClient = new ManagersRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _alertsRestClient = new AlertsRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _backupsRestClient = new BackupsRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _hardwareComponentGroupsRestClient = new HardwareComponentGroupsRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _volumesRestClient = new VolumesRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Initializes a new instance of the <see cref="Device"/> class. </summary>
        /// <param name="options"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal Device(ArmResource options, ResourceIdentifier id) : base(options, id)
        {
            _clientDiagnostics = new ClientDiagnostics(ClientOptions);
            ClientOptions.TryGetApiVersion(ResourceType, out string apiVersion);
            _devicesRestClient = new DevicesRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _managersRestClient = new ManagersRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _alertsRestClient = new AlertsRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _backupsRestClient = new BackupsRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _hardwareComponentGroupsRestClient = new HardwareComponentGroupsRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _volumesRestClient = new VolumesRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Initializes a new instance of the <see cref="Device"/> class. </summary>
        /// <param name="clientOptions"> The client options to build client context. </param>
        /// <param name="credential"> The credential to build client context. </param>
        /// <param name="uri"> The uri to build client context. </param>
        /// <param name="pipeline"> The pipeline to build client context. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal Device(ArmClientOptions clientOptions, TokenCredential credential, Uri uri, HttpPipeline pipeline, ResourceIdentifier id) : base(clientOptions, credential, uri, pipeline, id)
        {
            _clientDiagnostics = new ClientDiagnostics(ClientOptions);
            ClientOptions.TryGetApiVersion(ResourceType, out string apiVersion);
            _devicesRestClient = new DevicesRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _managersRestClient = new ManagersRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _alertsRestClient = new AlertsRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _backupsRestClient = new BackupsRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _hardwareComponentGroupsRestClient = new HardwareComponentGroupsRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _volumesRestClient = new VolumesRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.StorSimple/managers/devices";

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual DeviceData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary> Returns the properties of the specified device. </summary>
        /// <param name="expand"> Specify $expand=details to populate additional fields related to the device or $expand=rolloverdetails to populate additional fields related to the service data encryption key rollover on device. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<Response<Device>> GetAsync(string expand = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.Get");
            scope.Start();
            try
            {
                var response = await _devicesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, expand, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(response.GetRawResponse()).ConfigureAwait(false);
                return Response.FromValue(new Device(this, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the properties of the specified device. </summary>
        /// <param name="expand"> Specify $expand=details to populate additional fields related to the device or $expand=rolloverdetails to populate additional fields related to the service data encryption key rollover on device. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<Device> Get(string expand = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.Get");
            scope.Start();
            try
            {
                var response = _devicesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, expand, cancellationToken);
                if (response.Value == null)
                    throw _clientDiagnostics.CreateRequestFailedException(response.GetRawResponse());
                return Response.FromValue(new Device(this, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all available geo-locations. </summary>
        /// <param name="cancellationToken"> A token to allow the caller to cancel the call to the service. The default value is <see cref="CancellationToken.None" />. </param>
        /// <returns> A collection of locations that may take multiple service requests to iterate over. </returns>
        public async virtual Task<IEnumerable<AzureLocation>> GetAvailableLocationsAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.GetAvailableLocations");
            scope.Start();
            try
            {
                return await ListAvailableLocationsAsync(ResourceType, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all available geo-locations. </summary>
        /// <param name="cancellationToken"> A token to allow the caller to cancel the call to the service. The default value is <see cref="CancellationToken.None" />. </param>
        /// <returns> A collection of locations that may take multiple service requests to iterate over. </returns>
        public virtual IEnumerable<AzureLocation> GetAvailableLocations(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.GetAvailableLocations");
            scope.Start();
            try
            {
                return ListAvailableLocations(ResourceType, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes the device. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<DeviceDeleteOperation> DeleteAsync(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.Delete");
            scope.Start();
            try
            {
                var response = await _devicesRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new DeviceDeleteOperation(_clientDiagnostics, Pipeline, _devicesRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes the device. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeviceDeleteOperation Delete(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.Delete");
            scope.Start();
            try
            {
                var response = _devicesRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new DeviceDeleteOperation(_clientDiagnostics, Pipeline, _devicesRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Patches the device. </summary>
        /// <param name="parameters"> Patch representation of the device. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="parameters"/> is null. </exception>
        public async virtual Task<Response<Device>> UpdateAsync(DevicePatch parameters, CancellationToken cancellationToken = default)
        {
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope = _clientDiagnostics.CreateScope("Device.Update");
            scope.Start();
            try
            {
                var response = await _devicesRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, parameters, cancellationToken).ConfigureAwait(false);
                return Response.FromValue(new Device(this, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Patches the device. </summary>
        /// <param name="parameters"> Patch representation of the device. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="parameters"/> is null. </exception>
        public virtual Response<Device> Update(DevicePatch parameters, CancellationToken cancellationToken = default)
        {
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope = _clientDiagnostics.CreateScope("Device.Update");
            scope.Start();
            try
            {
                var response = _devicesRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, parameters, cancellationToken);
                return Response.FromValue(new Device(this, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the public encryption key of the device. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<Response<PublicKey>> GetDevicePublicEncryptionKeyManagerAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.GetDevicePublicEncryptionKeyManager");
            scope.Start();
            try
            {
                var response = await _managersRestClient.GetDevicePublicEncryptionKeyAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the public encryption key of the device. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<PublicKey> GetDevicePublicEncryptionKeyManager(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.GetDevicePublicEncryptionKeyManager");
            scope.Start();
            try
            {
                var response = _managersRestClient.GetDevicePublicEncryptionKey(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Sends a test alert email. </summary>
        /// <param name="parameters"> The send test alert email request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="parameters"/> is null. </exception>
        public async virtual Task<Response> SendTestEmailAlertAsync(SendTestAlertEmailRequest parameters, CancellationToken cancellationToken = default)
        {
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope = _clientDiagnostics.CreateScope("Device.SendTestEmailAlert");
            scope.Start();
            try
            {
                var response = await _alertsRestClient.SendTestEmailAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, parameters, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Sends a test alert email. </summary>
        /// <param name="parameters"> The send test alert email request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="parameters"/> is null. </exception>
        public virtual Response SendTestEmailAlert(SendTestAlertEmailRequest parameters, CancellationToken cancellationToken = default)
        {
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope = _clientDiagnostics.CreateScope("Device.SendTestEmailAlert");
            scope.Start();
            try
            {
                var response = _alertsRestClient.SendTestEmail(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, parameters, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Authorizes the specified device for service data encryption key rollover. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<Response> AuthorizeForServiceEncryptionKeyRolloverAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.AuthorizeForServiceEncryptionKeyRollover");
            scope.Start();
            try
            {
                var response = await _devicesRestClient.AuthorizeForServiceEncryptionKeyRolloverAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Authorizes the specified device for service data encryption key rollover. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response AuthorizeForServiceEncryptionKeyRollover(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.AuthorizeForServiceEncryptionKeyRollover");
            scope.Start();
            try
            {
                var response = _devicesRestClient.AuthorizeForServiceEncryptionKeyRollover(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deactivates the device. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<DeviceDeactivateOperation> DeactivateAsync(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.Deactivate");
            scope.Start();
            try
            {
                var response = await _devicesRestClient.DeactivateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new DeviceDeactivateOperation(_clientDiagnostics, Pipeline, _devicesRestClient.CreateDeactivateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deactivates the device. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeviceDeactivateOperation Deactivate(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.Deactivate");
            scope.Start();
            try
            {
                var response = _devicesRestClient.Deactivate(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new DeviceDeactivateOperation(_clientDiagnostics, Pipeline, _devicesRestClient.CreateDeactivateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Downloads and installs the updates on the device. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<DeviceInstallUpdatesOperation> InstallUpdatesAsync(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.InstallUpdates");
            scope.Start();
            try
            {
                var response = await _devicesRestClient.InstallUpdatesAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new DeviceInstallUpdatesOperation(_clientDiagnostics, Pipeline, _devicesRestClient.CreateInstallUpdatesRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Downloads and installs the updates on the device. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeviceInstallUpdatesOperation InstallUpdates(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.InstallUpdates");
            scope.Start();
            try
            {
                var response = _devicesRestClient.InstallUpdates(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new DeviceInstallUpdatesOperation(_clientDiagnostics, Pipeline, _devicesRestClient.CreateInstallUpdatesRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns all failover sets for a given device and their eligibility for participating in a failover. A failover set refers to a set of volume containers that need to be failed-over as a single unit to maintain data integrity. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="FailoverSet" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<FailoverSet> GetFailoverSetsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<FailoverSet>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetFailoverSets");
                scope.Start();
                try
                {
                    var response = await _devicesRestClient.ListFailoverSetsAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary> Returns all failover sets for a given device and their eligibility for participating in a failover. A failover set refers to a set of volume containers that need to be failed-over as a single unit to maintain data integrity. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="FailoverSet" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<FailoverSet> GetFailoverSets(CancellationToken cancellationToken = default)
        {
            Page<FailoverSet> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetFailoverSets");
                scope.Start();
                try
                {
                    var response = _devicesRestClient.ListFailoverSets(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary> Gets the metrics for the specified device. </summary>
        /// <param name="filter"> OData Filter options. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filter"/> is null. </exception>
        /// <returns> An async collection of <see cref="Metrics" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<Metrics> GetMetricsAsync(string filter, CancellationToken cancellationToken = default)
        {
            if (filter == null)
            {
                throw new ArgumentNullException(nameof(filter));
            }

            async Task<Page<Metrics>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetMetrics");
                scope.Start();
                try
                {
                    var response = await _devicesRestClient.ListMetricsAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, filter, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary> Gets the metrics for the specified device. </summary>
        /// <param name="filter"> OData Filter options. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filter"/> is null. </exception>
        /// <returns> A collection of <see cref="Metrics" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<Metrics> GetMetrics(string filter, CancellationToken cancellationToken = default)
        {
            if (filter == null)
            {
                throw new ArgumentNullException(nameof(filter));
            }

            Page<Metrics> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetMetrics");
                scope.Start();
                try
                {
                    var response = _devicesRestClient.ListMetrics(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, filter, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary> Gets the metric definitions for the specified device. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="MetricDefinition" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<MetricDefinition> GetMetricDefinitionAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<MetricDefinition>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetMetricDefinition");
                scope.Start();
                try
                {
                    var response = await _devicesRestClient.ListMetricDefinitionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary> Gets the metric definitions for the specified device. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="MetricDefinition" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<MetricDefinition> GetMetricDefinition(CancellationToken cancellationToken = default)
        {
            Page<MetricDefinition> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetMetricDefinition");
                scope.Start();
                try
                {
                    var response = _devicesRestClient.ListMetricDefinition(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary> Scans for updates on the device. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<DeviceScanForUpdatesOperation> ScanForUpdatesAsync(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.ScanForUpdates");
            scope.Start();
            try
            {
                var response = await _devicesRestClient.ScanForUpdatesAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new DeviceScanForUpdatesOperation(_clientDiagnostics, Pipeline, _devicesRestClient.CreateScanForUpdatesRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Scans for updates on the device. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeviceScanForUpdatesOperation ScanForUpdates(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("Device.ScanForUpdates");
            scope.Start();
            try
            {
                var response = _devicesRestClient.ScanForUpdates(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new DeviceScanForUpdatesOperation(_clientDiagnostics, Pipeline, _devicesRestClient.CreateScanForUpdatesRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Failovers a set of volume containers from a specified source device to a target device. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="parameters"> FailoverRequest containing the source device and the list of volume containers to be failed over. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="parameters"/> is null. </exception>
        public async virtual Task<DeviceFailoverOperation> FailoverAsync(bool waitForCompletion, FailoverRequest parameters, CancellationToken cancellationToken = default)
        {
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope = _clientDiagnostics.CreateScope("Device.Failover");
            scope.Start();
            try
            {
                var response = await _devicesRestClient.FailoverAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, parameters, cancellationToken).ConfigureAwait(false);
                var operation = new DeviceFailoverOperation(_clientDiagnostics, Pipeline, _devicesRestClient.CreateFailoverRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, parameters).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Failovers a set of volume containers from a specified source device to a target device. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="parameters"> FailoverRequest containing the source device and the list of volume containers to be failed over. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="parameters"/> is null. </exception>
        public virtual DeviceFailoverOperation Failover(bool waitForCompletion, FailoverRequest parameters, CancellationToken cancellationToken = default)
        {
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope = _clientDiagnostics.CreateScope("Device.Failover");
            scope.Start();
            try
            {
                var response = _devicesRestClient.Failover(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, parameters, cancellationToken);
                var operation = new DeviceFailoverOperation(_clientDiagnostics, Pipeline, _devicesRestClient.CreateFailoverRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, parameters).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Given a list of volume containers to be failed over from a source device, this method returns the eligibility result, as a failover target, for all devices under that resource. </summary>
        /// <param name="parameters"> ListFailoverTargetsRequest containing the list of volume containers to be failed over. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="parameters"/> is null. </exception>
        /// <returns> An async collection of <see cref="FailoverTarget" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<FailoverTarget> GetFailoverTargetsAsync(ListFailoverTargetsRequest parameters, CancellationToken cancellationToken = default)
        {
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            async Task<Page<FailoverTarget>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetFailoverTargets");
                scope.Start();
                try
                {
                    var response = await _devicesRestClient.ListFailoverTargetsAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, parameters, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary> Given a list of volume containers to be failed over from a source device, this method returns the eligibility result, as a failover target, for all devices under that resource. </summary>
        /// <param name="parameters"> ListFailoverTargetsRequest containing the list of volume containers to be failed over. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="parameters"/> is null. </exception>
        /// <returns> A collection of <see cref="FailoverTarget" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<FailoverTarget> GetFailoverTargets(ListFailoverTargetsRequest parameters, CancellationToken cancellationToken = default)
        {
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            Page<FailoverTarget> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetFailoverTargets");
                scope.Start();
                try
                {
                    var response = _devicesRestClient.ListFailoverTargets(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, parameters, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary> Retrieves all the backups in a device. </summary>
        /// <param name="filter"> OData Filter options. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="Backup" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<Backup> GetBackupsAsync(string filter = null, CancellationToken cancellationToken = default)
        {
            async Task<Page<Backup>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetBackups");
                scope.Start();
                try
                {
                    var response = await _backupsRestClient.ListByDeviceAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, filter, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<Backup>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetBackups");
                scope.Start();
                try
                {
                    var response = await _backupsRestClient.ListByDeviceNextPageAsync(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, filter, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Retrieves all the backups in a device. </summary>
        /// <param name="filter"> OData Filter options. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="Backup" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<Backup> GetBackups(string filter = null, CancellationToken cancellationToken = default)
        {
            Page<Backup> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetBackups");
                scope.Start();
                try
                {
                    var response = _backupsRestClient.ListByDevice(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, filter, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<Backup> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetBackups");
                scope.Start();
                try
                {
                    var response = _backupsRestClient.ListByDeviceNextPage(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, filter, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Deletes the backup. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="backupName"> The backup name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="backupName"/> is null. </exception>
        public async virtual Task<DeviceDeleteBackupOperation> DeleteBackupAsync(bool waitForCompletion, string backupName, CancellationToken cancellationToken = default)
        {
            if (backupName == null)
            {
                throw new ArgumentNullException(nameof(backupName));
            }

            using var scope = _clientDiagnostics.CreateScope("Device.DeleteBackup");
            scope.Start();
            try
            {
                var response = await _backupsRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, backupName, cancellationToken).ConfigureAwait(false);
                var operation = new DeviceDeleteBackupOperation(_clientDiagnostics, Pipeline, _backupsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, backupName).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes the backup. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="backupName"> The backup name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="backupName"/> is null. </exception>
        public virtual DeviceDeleteBackupOperation DeleteBackup(bool waitForCompletion, string backupName, CancellationToken cancellationToken = default)
        {
            if (backupName == null)
            {
                throw new ArgumentNullException(nameof(backupName));
            }

            using var scope = _clientDiagnostics.CreateScope("Device.DeleteBackup");
            scope.Start();
            try
            {
                var response = _backupsRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, backupName, cancellationToken);
                var operation = new DeviceDeleteBackupOperation(_clientDiagnostics, Pipeline, _backupsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, backupName).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Clones the backup element as a new volume. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="backupName"> The backup name. </param>
        /// <param name="backupElementName"> The backup element name. </param>
        /// <param name="parameters"> The clone request object. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="backupName"/>, <paramref name="backupElementName"/>, or <paramref name="parameters"/> is null. </exception>
        public async virtual Task<DeviceCloneBackupOperation> CloneBackupAsync(bool waitForCompletion, string backupName, string backupElementName, CloneRequest parameters, CancellationToken cancellationToken = default)
        {
            if (backupName == null)
            {
                throw new ArgumentNullException(nameof(backupName));
            }
            if (backupElementName == null)
            {
                throw new ArgumentNullException(nameof(backupElementName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope = _clientDiagnostics.CreateScope("Device.CloneBackup");
            scope.Start();
            try
            {
                var response = await _backupsRestClient.CloneAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, backupName, backupElementName, parameters, cancellationToken).ConfigureAwait(false);
                var operation = new DeviceCloneBackupOperation(_clientDiagnostics, Pipeline, _backupsRestClient.CreateCloneRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, backupName, backupElementName, parameters).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Clones the backup element as a new volume. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="backupName"> The backup name. </param>
        /// <param name="backupElementName"> The backup element name. </param>
        /// <param name="parameters"> The clone request object. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="backupName"/>, <paramref name="backupElementName"/>, or <paramref name="parameters"/> is null. </exception>
        public virtual DeviceCloneBackupOperation CloneBackup(bool waitForCompletion, string backupName, string backupElementName, CloneRequest parameters, CancellationToken cancellationToken = default)
        {
            if (backupName == null)
            {
                throw new ArgumentNullException(nameof(backupName));
            }
            if (backupElementName == null)
            {
                throw new ArgumentNullException(nameof(backupElementName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope = _clientDiagnostics.CreateScope("Device.CloneBackup");
            scope.Start();
            try
            {
                var response = _backupsRestClient.Clone(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, backupName, backupElementName, parameters, cancellationToken);
                var operation = new DeviceCloneBackupOperation(_clientDiagnostics, Pipeline, _backupsRestClient.CreateCloneRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, backupName, backupElementName, parameters).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Restores the backup on the device. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="backupName"> The backupSet name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="backupName"/> is null. </exception>
        public async virtual Task<DeviceRestoreBackupOperation> RestoreBackupAsync(bool waitForCompletion, string backupName, CancellationToken cancellationToken = default)
        {
            if (backupName == null)
            {
                throw new ArgumentNullException(nameof(backupName));
            }

            using var scope = _clientDiagnostics.CreateScope("Device.RestoreBackup");
            scope.Start();
            try
            {
                var response = await _backupsRestClient.RestoreAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, backupName, cancellationToken).ConfigureAwait(false);
                var operation = new DeviceRestoreBackupOperation(_clientDiagnostics, Pipeline, _backupsRestClient.CreateRestoreRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, backupName).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Restores the backup on the device. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="backupName"> The backupSet name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="backupName"/> is null. </exception>
        public virtual DeviceRestoreBackupOperation RestoreBackup(bool waitForCompletion, string backupName, CancellationToken cancellationToken = default)
        {
            if (backupName == null)
            {
                throw new ArgumentNullException(nameof(backupName));
            }

            using var scope = _clientDiagnostics.CreateScope("Device.RestoreBackup");
            scope.Start();
            try
            {
                var response = _backupsRestClient.Restore(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, backupName, cancellationToken);
                var operation = new DeviceRestoreBackupOperation(_clientDiagnostics, Pipeline, _backupsRestClient.CreateRestoreRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, backupName).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the hardware component groups at device-level. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="HardwareComponentGroup" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<HardwareComponentGroup> GetHardwareComponentGroupsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<HardwareComponentGroup>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetHardwareComponentGroups");
                scope.Start();
                try
                {
                    var response = await _hardwareComponentGroupsRestClient.ListByDeviceAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary> Lists the hardware component groups at device-level. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="HardwareComponentGroup" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<HardwareComponentGroup> GetHardwareComponentGroups(CancellationToken cancellationToken = default)
        {
            Page<HardwareComponentGroup> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetHardwareComponentGroups");
                scope.Start();
                try
                {
                    var response = _hardwareComponentGroupsRestClient.ListByDevice(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary> Changes the power state of the controller. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="hardwareComponentGroupName"> The hardware component group name. </param>
        /// <param name="parameters"> The controller power state change request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="hardwareComponentGroupName"/> or <paramref name="parameters"/> is null. </exception>
        public async virtual Task<DeviceChangeControllerPowerStateHardwareComponentGroupOperation> ChangeControllerPowerStateHardwareComponentGroupAsync(bool waitForCompletion, string hardwareComponentGroupName, ControllerPowerStateChangeRequest parameters, CancellationToken cancellationToken = default)
        {
            if (hardwareComponentGroupName == null)
            {
                throw new ArgumentNullException(nameof(hardwareComponentGroupName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope = _clientDiagnostics.CreateScope("Device.ChangeControllerPowerStateHardwareComponentGroup");
            scope.Start();
            try
            {
                var response = await _hardwareComponentGroupsRestClient.ChangeControllerPowerStateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, hardwareComponentGroupName, parameters, cancellationToken).ConfigureAwait(false);
                var operation = new DeviceChangeControllerPowerStateHardwareComponentGroupOperation(_clientDiagnostics, Pipeline, _hardwareComponentGroupsRestClient.CreateChangeControllerPowerStateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, hardwareComponentGroupName, parameters).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Changes the power state of the controller. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="hardwareComponentGroupName"> The hardware component group name. </param>
        /// <param name="parameters"> The controller power state change request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="hardwareComponentGroupName"/> or <paramref name="parameters"/> is null. </exception>
        public virtual DeviceChangeControllerPowerStateHardwareComponentGroupOperation ChangeControllerPowerStateHardwareComponentGroup(bool waitForCompletion, string hardwareComponentGroupName, ControllerPowerStateChangeRequest parameters, CancellationToken cancellationToken = default)
        {
            if (hardwareComponentGroupName == null)
            {
                throw new ArgumentNullException(nameof(hardwareComponentGroupName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope = _clientDiagnostics.CreateScope("Device.ChangeControllerPowerStateHardwareComponentGroup");
            scope.Start();
            try
            {
                var response = _hardwareComponentGroupsRestClient.ChangeControllerPowerState(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, hardwareComponentGroupName, parameters, cancellationToken);
                var operation = new DeviceChangeControllerPowerStateHardwareComponentGroupOperation(_clientDiagnostics, Pipeline, _hardwareComponentGroupsRestClient.CreateChangeControllerPowerStateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, hardwareComponentGroupName, parameters).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves all the volumes in a device. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="VolumeData" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<VolumeData> GetVolumesAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<VolumeData>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetVolumes");
                scope.Start();
                try
                {
                    var response = await _volumesRestClient.ListByDeviceAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary> Retrieves all the volumes in a device. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="VolumeData" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<VolumeData> GetVolumes(CancellationToken cancellationToken = default)
        {
            Page<VolumeData> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("Device.GetVolumes");
                scope.Start();
                try
                {
                    var response = _volumesRestClient.ListByDevice(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        #region Updates

        /// <summary> Gets an object representing a Updates along with the instance operations that can be performed on it in the Device. </summary>
        /// <returns> Returns a <see cref="Updates" /> object. </returns>
        public virtual Updates GetUpdates()
        {
            return new Updates(this, new ResourceIdentifier(Id.ToString() + "/updateSummary/default"));
        }
        #endregion

        #region AlertSettings

        /// <summary> Gets an object representing a AlertSettings along with the instance operations that can be performed on it in the Device. </summary>
        /// <returns> Returns a <see cref="AlertSettings" /> object. </returns>
        public virtual AlertSettings GetAlertSettings()
        {
            return new AlertSettings(this, new ResourceIdentifier(Id.ToString() + "/alertSettings/default"));
        }
        #endregion

        #region NetworkSettings

        /// <summary> Gets an object representing a NetworkSettings along with the instance operations that can be performed on it in the Device. </summary>
        /// <returns> Returns a <see cref="NetworkSettings" /> object. </returns>
        public virtual NetworkSettings GetNetworkSettings()
        {
            return new NetworkSettings(this, new ResourceIdentifier(Id.ToString() + "/networkSettings/default"));
        }
        #endregion

        #region SecuritySettings

        /// <summary> Gets an object representing a SecuritySettings along with the instance operations that can be performed on it in the Device. </summary>
        /// <returns> Returns a <see cref="SecuritySettings" /> object. </returns>
        public virtual SecuritySettings GetSecuritySettings()
        {
            return new SecuritySettings(this, new ResourceIdentifier(Id.ToString() + "/securitySettings/default"));
        }
        #endregion

        #region TimeSettings

        /// <summary> Gets an object representing a TimeSettings along with the instance operations that can be performed on it in the Device. </summary>
        /// <returns> Returns a <see cref="TimeSettings" /> object. </returns>
        public virtual TimeSettings GetTimeSettings()
        {
            return new TimeSettings(this, new ResourceIdentifier(Id.ToString() + "/timeSettings/default"));
        }
        #endregion

        #region BackupPolicy

        /// <summary> Gets a collection of BackupPolicies in the Device. </summary>
        /// <returns> An object representing collection of BackupPolicies and their operations over a Device. </returns>
        public virtual BackupPolicyCollection GetBackupPolicies()
        {
            return new BackupPolicyCollection(this);
        }
        #endregion

        #region Job

        /// <summary> Gets a collection of Jobs in the Device. </summary>
        /// <returns> An object representing collection of Jobs and their operations over a Device. </returns>
        public virtual JobCollection GetJobs()
        {
            return new JobCollection(this);
        }
        #endregion

        #region VolumeContainer

        /// <summary> Gets a collection of VolumeContainers in the Device. </summary>
        /// <returns> An object representing collection of VolumeContainers and their operations over a Device. </returns>
        public virtual VolumeContainerCollection GetVolumeContainers()
        {
            return new VolumeContainerCollection(this);
        }
        #endregion
    }
}
