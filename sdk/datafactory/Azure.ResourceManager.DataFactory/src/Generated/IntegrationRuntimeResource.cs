// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager;
using Azure.ResourceManager.Core;
using Azure.ResourceManager.DataFactory.Models;

namespace Azure.ResourceManager.DataFactory
{
    /// <summary> A Class representing a IntegrationRuntimeResource along with the instance operations that can be performed on it. </summary>
    public partial class IntegrationRuntimeResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="IntegrationRuntimeResource"/> instance. </summary>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string factoryName, string integrationRuntimeName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/integrationRuntimes/{integrationRuntimeName}";
            return new ResourceIdentifier(resourceId);
        }
        private readonly ClientDiagnostics _clientDiagnostics;
        private readonly IntegrationRuntimesRestOperations _integrationRuntimesRestClient;
        private readonly IntegrationRuntimeObjectMetadataRestOperations _integrationRuntimeObjectMetadataRestClient;
        private readonly IntegrationRuntimeNodesRestOperations _integrationRuntimeNodesRestClient;
        private readonly IntegrationRuntimeResourceData _data;

        /// <summary> Initializes a new instance of the <see cref="IntegrationRuntimeResource"/> class for mocking. </summary>
        protected IntegrationRuntimeResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref = "IntegrationRuntimeResource"/> class. </summary>
        /// <param name="options"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal IntegrationRuntimeResource(ArmResource options, IntegrationRuntimeResourceData data) : base(options, data.Id)
        {
            HasData = true;
            _data = data;
            _clientDiagnostics = new ClientDiagnostics(ClientOptions);
            ClientOptions.TryGetApiVersion(ResourceType, out string apiVersion);
            _integrationRuntimesRestClient = new IntegrationRuntimesRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _integrationRuntimeObjectMetadataRestClient = new IntegrationRuntimeObjectMetadataRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _integrationRuntimeNodesRestClient = new IntegrationRuntimeNodesRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Initializes a new instance of the <see cref="IntegrationRuntimeResource"/> class. </summary>
        /// <param name="options"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal IntegrationRuntimeResource(ArmResource options, ResourceIdentifier id) : base(options, id)
        {
            _clientDiagnostics = new ClientDiagnostics(ClientOptions);
            ClientOptions.TryGetApiVersion(ResourceType, out string apiVersion);
            _integrationRuntimesRestClient = new IntegrationRuntimesRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _integrationRuntimeObjectMetadataRestClient = new IntegrationRuntimeObjectMetadataRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _integrationRuntimeNodesRestClient = new IntegrationRuntimeNodesRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Initializes a new instance of the <see cref="IntegrationRuntimeResource"/> class. </summary>
        /// <param name="clientOptions"> The client options to build client context. </param>
        /// <param name="credential"> The credential to build client context. </param>
        /// <param name="uri"> The uri to build client context. </param>
        /// <param name="pipeline"> The pipeline to build client context. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal IntegrationRuntimeResource(ArmClientOptions clientOptions, TokenCredential credential, Uri uri, HttpPipeline pipeline, ResourceIdentifier id) : base(clientOptions, credential, uri, pipeline, id)
        {
            _clientDiagnostics = new ClientDiagnostics(ClientOptions);
            ClientOptions.TryGetApiVersion(ResourceType, out string apiVersion);
            _integrationRuntimesRestClient = new IntegrationRuntimesRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _integrationRuntimeObjectMetadataRestClient = new IntegrationRuntimeObjectMetadataRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
            _integrationRuntimeNodesRestClient = new IntegrationRuntimeNodesRestOperations(_clientDiagnostics, Pipeline, ClientOptions, BaseUri, apiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.DataFactory/factories/integrationRuntimes";

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual IntegrationRuntimeResourceData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary> Gets an integration runtime. </summary>
        /// <param name="ifNoneMatch"> ETag of the integration runtime entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was provided, then no content will be returned. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<Response<IntegrationRuntimeResource>> GetAsync(string ifNoneMatch = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.Get");
            scope.Start();
            try
            {
                var response = await _integrationRuntimesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, ifNoneMatch, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(response.GetRawResponse()).ConfigureAwait(false);
                return Response.FromValue(new IntegrationRuntimeResource(this, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets an integration runtime. </summary>
        /// <param name="ifNoneMatch"> ETag of the integration runtime entity. Should only be specified for get. If the ETag matches the existing entity tag, or if * was provided, then no content will be returned. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IntegrationRuntimeResource> Get(string ifNoneMatch = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.Get");
            scope.Start();
            try
            {
                var response = _integrationRuntimesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, ifNoneMatch, cancellationToken);
                if (response.Value == null)
                    throw _clientDiagnostics.CreateRequestFailedException(response.GetRawResponse());
                return Response.FromValue(new IntegrationRuntimeResource(this, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all available geo-locations. </summary>
        /// <param name="cancellationToken"> A token to allow the caller to cancel the call to the service. The default value is <see cref="CancellationToken.None" />. </param>
        /// <returns> A collection of locations that may take multiple service requests to iterate over. </returns>
        public async virtual Task<IEnumerable<AzureLocation>> GetAvailableLocationsAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetAvailableLocations");
            scope.Start();
            try
            {
                return await ListAvailableLocationsAsync(ResourceType, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all available geo-locations. </summary>
        /// <param name="cancellationToken"> A token to allow the caller to cancel the call to the service. The default value is <see cref="CancellationToken.None" />. </param>
        /// <returns> A collection of locations that may take multiple service requests to iterate over. </returns>
        public virtual IEnumerable<AzureLocation> GetAvailableLocations(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetAvailableLocations");
            scope.Start();
            try
            {
                return ListAvailableLocations(ResourceType, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes an integration runtime. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<IntegrationRuntimeResourceDeleteOperation> DeleteAsync(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.Delete");
            scope.Start();
            try
            {
                var response = await _integrationRuntimesRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new IntegrationRuntimeResourceDeleteOperation(response);
                if (waitForCompletion)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes an integration runtime. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual IntegrationRuntimeResourceDeleteOperation Delete(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.Delete");
            scope.Start();
            try
            {
                var response = _integrationRuntimesRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new IntegrationRuntimeResourceDeleteOperation(response);
                if (waitForCompletion)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates an integration runtime. </summary>
        /// <param name="updateIntegrationRuntimeRequest"> The parameters for updating an integration runtime. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="updateIntegrationRuntimeRequest"/> is null. </exception>
        public async virtual Task<Response<IntegrationRuntimeResource>> UpdateAsync(UpdateIntegrationRuntimeRequest updateIntegrationRuntimeRequest, CancellationToken cancellationToken = default)
        {
            if (updateIntegrationRuntimeRequest == null)
            {
                throw new ArgumentNullException(nameof(updateIntegrationRuntimeRequest));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.Update");
            scope.Start();
            try
            {
                var response = await _integrationRuntimesRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, updateIntegrationRuntimeRequest, cancellationToken).ConfigureAwait(false);
                return Response.FromValue(new IntegrationRuntimeResource(this, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates an integration runtime. </summary>
        /// <param name="updateIntegrationRuntimeRequest"> The parameters for updating an integration runtime. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="updateIntegrationRuntimeRequest"/> is null. </exception>
        public virtual Response<IntegrationRuntimeResource> Update(UpdateIntegrationRuntimeRequest updateIntegrationRuntimeRequest, CancellationToken cancellationToken = default)
        {
            if (updateIntegrationRuntimeRequest == null)
            {
                throw new ArgumentNullException(nameof(updateIntegrationRuntimeRequest));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.Update");
            scope.Start();
            try
            {
                var response = _integrationRuntimesRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, updateIntegrationRuntimeRequest, cancellationToken);
                return Response.FromValue(new IntegrationRuntimeResource(this, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets detailed status information for an integration runtime. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<Response<IntegrationRuntimeStatusResponse>> GetStatusAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetStatus");
            scope.Start();
            try
            {
                var response = await _integrationRuntimesRestClient.GetStatusAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets detailed status information for an integration runtime. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IntegrationRuntimeStatusResponse> GetStatus(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetStatus");
            scope.Start();
            try
            {
                var response = _integrationRuntimesRestClient.GetStatus(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the list of outbound network dependencies for a given Azure-SSIS integration runtime. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint> GetOutboundNetworkDependenciesEndpointsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetOutboundNetworkDependenciesEndpoints");
                scope.Start();
                try
                {
                    var response = await _integrationRuntimesRestClient.ListOutboundNetworkDependenciesEndpointsAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary> Gets the list of outbound network dependencies for a given Azure-SSIS integration runtime. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint> GetOutboundNetworkDependenciesEndpoints(CancellationToken cancellationToken = default)
        {
            Page<IntegrationRuntimeOutboundNetworkDependenciesCategoryEndpoint> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetOutboundNetworkDependenciesEndpoints");
                scope.Start();
                try
                {
                    var response = _integrationRuntimesRestClient.ListOutboundNetworkDependenciesEndpoints(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary> Gets the on-premises integration runtime connection information for encrypting the on-premises data source credentials. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<Response<IntegrationRuntimeConnectionInfo>> GetConnectionInfoAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetConnectionInfo");
            scope.Start();
            try
            {
                var response = await _integrationRuntimesRestClient.GetConnectionInfoAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the on-premises integration runtime connection information for encrypting the on-premises data source credentials. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IntegrationRuntimeConnectionInfo> GetConnectionInfo(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetConnectionInfo");
            scope.Start();
            try
            {
                var response = _integrationRuntimesRestClient.GetConnectionInfo(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Regenerates the authentication key for an integration runtime. </summary>
        /// <param name="regenerateKeyParameters"> The parameters for regenerating integration runtime authentication key. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="regenerateKeyParameters"/> is null. </exception>
        public async virtual Task<Response<IntegrationRuntimeAuthKeys>> RegenerateAuthKeyAsync(IntegrationRuntimeRegenerateKeyParameters regenerateKeyParameters, CancellationToken cancellationToken = default)
        {
            if (regenerateKeyParameters == null)
            {
                throw new ArgumentNullException(nameof(regenerateKeyParameters));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.RegenerateAuthKey");
            scope.Start();
            try
            {
                var response = await _integrationRuntimesRestClient.RegenerateAuthKeyAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, regenerateKeyParameters, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Regenerates the authentication key for an integration runtime. </summary>
        /// <param name="regenerateKeyParameters"> The parameters for regenerating integration runtime authentication key. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="regenerateKeyParameters"/> is null. </exception>
        public virtual Response<IntegrationRuntimeAuthKeys> RegenerateAuthKey(IntegrationRuntimeRegenerateKeyParameters regenerateKeyParameters, CancellationToken cancellationToken = default)
        {
            if (regenerateKeyParameters == null)
            {
                throw new ArgumentNullException(nameof(regenerateKeyParameters));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.RegenerateAuthKey");
            scope.Start();
            try
            {
                var response = _integrationRuntimesRestClient.RegenerateAuthKey(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, regenerateKeyParameters, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves the authentication keys for an integration runtime. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<Response<IntegrationRuntimeAuthKeys>> GetAuthKeysAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetAuthKeys");
            scope.Start();
            try
            {
                var response = await _integrationRuntimesRestClient.ListAuthKeysAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieves the authentication keys for an integration runtime. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IntegrationRuntimeAuthKeys> GetAuthKeys(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetAuthKeys");
            scope.Start();
            try
            {
                var response = _integrationRuntimesRestClient.ListAuthKeys(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Starts a ManagedReserved type integration runtime. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<IntegrationRuntimeResourceStartOperation> StartAsync(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.Start");
            scope.Start();
            try
            {
                var response = await _integrationRuntimesRestClient.StartAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new IntegrationRuntimeResourceStartOperation(_clientDiagnostics, Pipeline, _integrationRuntimesRestClient.CreateStartRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Starts a ManagedReserved type integration runtime. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual IntegrationRuntimeResourceStartOperation Start(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.Start");
            scope.Start();
            try
            {
                var response = _integrationRuntimesRestClient.Start(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new IntegrationRuntimeResourceStartOperation(_clientDiagnostics, Pipeline, _integrationRuntimesRestClient.CreateStartRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Stops a ManagedReserved type integration runtime. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<IntegrationRuntimeResourceStopOperation> StopAsync(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.Stop");
            scope.Start();
            try
            {
                var response = await _integrationRuntimesRestClient.StopAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new IntegrationRuntimeResourceStopOperation(_clientDiagnostics, Pipeline, _integrationRuntimesRestClient.CreateStopRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Stops a ManagedReserved type integration runtime. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual IntegrationRuntimeResourceStopOperation Stop(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.Stop");
            scope.Start();
            try
            {
                var response = _integrationRuntimesRestClient.Stop(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new IntegrationRuntimeResourceStopOperation(_clientDiagnostics, Pipeline, _integrationRuntimesRestClient.CreateStopRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Force the integration runtime to synchronize credentials across integration runtime nodes, and this will override the credentials across all worker nodes with those available on the dispatcher node. If you already have the latest credential backup file, you should manually import it (preferred) on any self-hosted integration runtime node than using this API directly. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<Response> SyncCredentialsAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.SyncCredentials");
            scope.Start();
            try
            {
                var response = await _integrationRuntimesRestClient.SyncCredentialsAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Force the integration runtime to synchronize credentials across integration runtime nodes, and this will override the credentials across all worker nodes with those available on the dispatcher node. If you already have the latest credential backup file, you should manually import it (preferred) on any self-hosted integration runtime node than using this API directly. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response SyncCredentials(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.SyncCredentials");
            scope.Start();
            try
            {
                var response = _integrationRuntimesRestClient.SyncCredentials(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the integration runtime monitoring data, which includes the monitor data for all the nodes under this integration runtime. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<Response<IntegrationRuntimeMonitoringData>> GetMonitoringDataAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetMonitoringData");
            scope.Start();
            try
            {
                var response = await _integrationRuntimesRestClient.GetMonitoringDataAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the integration runtime monitoring data, which includes the monitor data for all the nodes under this integration runtime. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IntegrationRuntimeMonitoringData> GetMonitoringData(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetMonitoringData");
            scope.Start();
            try
            {
                var response = _integrationRuntimesRestClient.GetMonitoringData(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Upgrade self-hosted integration runtime to latest version if availability. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<Response> UpgradeAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.Upgrade");
            scope.Start();
            try
            {
                var response = await _integrationRuntimesRestClient.UpgradeAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Upgrade self-hosted integration runtime to latest version if availability. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response Upgrade(CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.Upgrade");
            scope.Start();
            try
            {
                var response = _integrationRuntimesRestClient.Upgrade(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Remove all linked integration runtimes under specific data factory in a self-hosted integration runtime. </summary>
        /// <param name="linkedIntegrationRuntimeRequest"> The data factory name for the linked integration runtime. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="linkedIntegrationRuntimeRequest"/> is null. </exception>
        public async virtual Task<Response> RemoveLinksAsync(LinkedIntegrationRuntimeRequest linkedIntegrationRuntimeRequest, CancellationToken cancellationToken = default)
        {
            if (linkedIntegrationRuntimeRequest == null)
            {
                throw new ArgumentNullException(nameof(linkedIntegrationRuntimeRequest));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.RemoveLinks");
            scope.Start();
            try
            {
                var response = await _integrationRuntimesRestClient.RemoveLinksAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, linkedIntegrationRuntimeRequest, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Remove all linked integration runtimes under specific data factory in a self-hosted integration runtime. </summary>
        /// <param name="linkedIntegrationRuntimeRequest"> The data factory name for the linked integration runtime. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="linkedIntegrationRuntimeRequest"/> is null. </exception>
        public virtual Response RemoveLinks(LinkedIntegrationRuntimeRequest linkedIntegrationRuntimeRequest, CancellationToken cancellationToken = default)
        {
            if (linkedIntegrationRuntimeRequest == null)
            {
                throw new ArgumentNullException(nameof(linkedIntegrationRuntimeRequest));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.RemoveLinks");
            scope.Start();
            try
            {
                var response = _integrationRuntimesRestClient.RemoveLinks(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, linkedIntegrationRuntimeRequest, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a linked integration runtime entry in a shared integration runtime. </summary>
        /// <param name="createLinkedIntegrationRuntimeRequest"> The linked integration runtime properties. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="createLinkedIntegrationRuntimeRequest"/> is null. </exception>
        public async virtual Task<Response<IntegrationRuntimeStatusResponse>> CreateLinkedIntegrationRuntimeAsync(CreateLinkedIntegrationRuntimeRequest createLinkedIntegrationRuntimeRequest, CancellationToken cancellationToken = default)
        {
            if (createLinkedIntegrationRuntimeRequest == null)
            {
                throw new ArgumentNullException(nameof(createLinkedIntegrationRuntimeRequest));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.CreateLinkedIntegrationRuntime");
            scope.Start();
            try
            {
                var response = await _integrationRuntimesRestClient.CreateLinkedIntegrationRuntimeAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, createLinkedIntegrationRuntimeRequest, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a linked integration runtime entry in a shared integration runtime. </summary>
        /// <param name="createLinkedIntegrationRuntimeRequest"> The linked integration runtime properties. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="createLinkedIntegrationRuntimeRequest"/> is null. </exception>
        public virtual Response<IntegrationRuntimeStatusResponse> CreateLinkedIntegrationRuntime(CreateLinkedIntegrationRuntimeRequest createLinkedIntegrationRuntimeRequest, CancellationToken cancellationToken = default)
        {
            if (createLinkedIntegrationRuntimeRequest == null)
            {
                throw new ArgumentNullException(nameof(createLinkedIntegrationRuntimeRequest));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.CreateLinkedIntegrationRuntime");
            scope.Start();
            try
            {
                var response = _integrationRuntimesRestClient.CreateLinkedIntegrationRuntime(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, createLinkedIntegrationRuntimeRequest, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Refresh a SSIS integration runtime object metadata. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<IntegrationRuntimeResourceRefreshIntegrationRuntimeObjectMetadataOperation> RefreshIntegrationRuntimeObjectMetadataAsync(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.RefreshIntegrationRuntimeObjectMetadata");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeObjectMetadataRestClient.RefreshAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new IntegrationRuntimeResourceRefreshIntegrationRuntimeObjectMetadataOperation(_clientDiagnostics, Pipeline, _integrationRuntimeObjectMetadataRestClient.CreateRefreshRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response);
                if (waitForCompletion)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Refresh a SSIS integration runtime object metadata. </summary>
        /// <param name="waitForCompletion"> Waits for the completion of the long running operations. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual IntegrationRuntimeResourceRefreshIntegrationRuntimeObjectMetadataOperation RefreshIntegrationRuntimeObjectMetadata(bool waitForCompletion, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.RefreshIntegrationRuntimeObjectMetadata");
            scope.Start();
            try
            {
                var response = _integrationRuntimeObjectMetadataRestClient.Refresh(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new IntegrationRuntimeResourceRefreshIntegrationRuntimeObjectMetadataOperation(_clientDiagnostics, Pipeline, _integrationRuntimeObjectMetadataRestClient.CreateRefreshRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response);
                if (waitForCompletion)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a SSIS integration runtime object metadata by specified path. The return is pageable metadata list. </summary>
        /// <param name="getMetadataRequest"> The parameters for getting a SSIS object metadata. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="SsisObjectMetadata" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<SsisObjectMetadata> GetAllIntegrationRuntimeObjectMetadataAsync(GetSsisObjectMetadataRequest getMetadataRequest = null, CancellationToken cancellationToken = default)
        {
            async Task<Page<SsisObjectMetadata>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetAllIntegrationRuntimeObjectMetadata");
                scope.Start();
                try
                {
                    var response = await _integrationRuntimeObjectMetadataRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, getMetadataRequest, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, null);
        }

        /// <summary> Get a SSIS integration runtime object metadata by specified path. The return is pageable metadata list. </summary>
        /// <param name="getMetadataRequest"> The parameters for getting a SSIS object metadata. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="SsisObjectMetadata" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<SsisObjectMetadata> GetAllIntegrationRuntimeObjectMetadata(GetSsisObjectMetadataRequest getMetadataRequest = null, CancellationToken cancellationToken = default)
        {
            Page<SsisObjectMetadata> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetAllIntegrationRuntimeObjectMetadata");
                scope.Start();
                try
                {
                    var response = _integrationRuntimeObjectMetadataRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, getMetadataRequest, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, null, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, null);
        }

        /// <summary> Gets a self-hosted integration runtime node. </summary>
        /// <param name="nodeName"> The integration runtime node name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> is null. </exception>
        public async virtual Task<Response<SelfHostedIntegrationRuntimeNode>> GetIntegrationRuntimeNodeAsync(string nodeName, CancellationToken cancellationToken = default)
        {
            if (nodeName == null)
            {
                throw new ArgumentNullException(nameof(nodeName));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIntegrationRuntimeNode");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeNodesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a self-hosted integration runtime node. </summary>
        /// <param name="nodeName"> The integration runtime node name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> is null. </exception>
        public virtual Response<SelfHostedIntegrationRuntimeNode> GetIntegrationRuntimeNode(string nodeName, CancellationToken cancellationToken = default)
        {
            if (nodeName == null)
            {
                throw new ArgumentNullException(nameof(nodeName));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIntegrationRuntimeNode");
            scope.Start();
            try
            {
                var response = _integrationRuntimeNodesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a self-hosted integration runtime node. </summary>
        /// <param name="nodeName"> The integration runtime node name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> is null. </exception>
        public async virtual Task<Response> DeleteIntegrationRuntimeNodeAsync(string nodeName, CancellationToken cancellationToken = default)
        {
            if (nodeName == null)
            {
                throw new ArgumentNullException(nameof(nodeName));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.DeleteIntegrationRuntimeNode");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeNodesRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a self-hosted integration runtime node. </summary>
        /// <param name="nodeName"> The integration runtime node name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> is null. </exception>
        public virtual Response DeleteIntegrationRuntimeNode(string nodeName, CancellationToken cancellationToken = default)
        {
            if (nodeName == null)
            {
                throw new ArgumentNullException(nameof(nodeName));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.DeleteIntegrationRuntimeNode");
            scope.Start();
            try
            {
                var response = _integrationRuntimeNodesRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates a self-hosted integration runtime node. </summary>
        /// <param name="nodeName"> The integration runtime node name. </param>
        /// <param name="updateIntegrationRuntimeNodeRequest"> The parameters for updating an integration runtime node. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> or <paramref name="updateIntegrationRuntimeNodeRequest"/> is null. </exception>
        public async virtual Task<Response<SelfHostedIntegrationRuntimeNode>> UpdateIntegrationRuntimeNodeAsync(string nodeName, UpdateIntegrationRuntimeNodeRequest updateIntegrationRuntimeNodeRequest, CancellationToken cancellationToken = default)
        {
            if (nodeName == null)
            {
                throw new ArgumentNullException(nameof(nodeName));
            }
            if (updateIntegrationRuntimeNodeRequest == null)
            {
                throw new ArgumentNullException(nameof(updateIntegrationRuntimeNodeRequest));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.UpdateIntegrationRuntimeNode");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeNodesRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, updateIntegrationRuntimeNodeRequest, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates a self-hosted integration runtime node. </summary>
        /// <param name="nodeName"> The integration runtime node name. </param>
        /// <param name="updateIntegrationRuntimeNodeRequest"> The parameters for updating an integration runtime node. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> or <paramref name="updateIntegrationRuntimeNodeRequest"/> is null. </exception>
        public virtual Response<SelfHostedIntegrationRuntimeNode> UpdateIntegrationRuntimeNode(string nodeName, UpdateIntegrationRuntimeNodeRequest updateIntegrationRuntimeNodeRequest, CancellationToken cancellationToken = default)
        {
            if (nodeName == null)
            {
                throw new ArgumentNullException(nameof(nodeName));
            }
            if (updateIntegrationRuntimeNodeRequest == null)
            {
                throw new ArgumentNullException(nameof(updateIntegrationRuntimeNodeRequest));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.UpdateIntegrationRuntimeNode");
            scope.Start();
            try
            {
                var response = _integrationRuntimeNodesRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, updateIntegrationRuntimeNodeRequest, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the IP address of self-hosted integration runtime node. </summary>
        /// <param name="nodeName"> The integration runtime node name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> is null. </exception>
        public async virtual Task<Response<IntegrationRuntimeNodeIpAddress>> GetIpAddressIntegrationRuntimeNodeAsync(string nodeName, CancellationToken cancellationToken = default)
        {
            if (nodeName == null)
            {
                throw new ArgumentNullException(nameof(nodeName));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIpAddressIntegrationRuntimeNode");
            scope.Start();
            try
            {
                var response = await _integrationRuntimeNodesRestClient.GetIpAddressAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the IP address of self-hosted integration runtime node. </summary>
        /// <param name="nodeName"> The integration runtime node name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nodeName"/> is null. </exception>
        public virtual Response<IntegrationRuntimeNodeIpAddress> GetIpAddressIntegrationRuntimeNode(string nodeName, CancellationToken cancellationToken = default)
        {
            if (nodeName == null)
            {
                throw new ArgumentNullException(nameof(nodeName));
            }

            using var scope = _clientDiagnostics.CreateScope("IntegrationRuntimeResource.GetIpAddressIntegrationRuntimeNode");
            scope.Start();
            try
            {
                var response = _integrationRuntimeNodesRestClient.GetIpAddress(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, nodeName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
